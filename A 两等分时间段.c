#include<stdio.h>
#include<string.h>

int ans,x[55];
int f[2][110][5015];/*求能够组成总和相同的两堆最多用去几个数*/

int main()
{
	int i,j,k,t,n,a,b;
	scanf("%d",&t);
	while(t--)
	{
		memset(f,0,sizeof(f));
		f[0][50][2500]=1;/*起点是1，位于[50][2500]，时间段个数不超50，时间段与区间乘积不超2500*/ 
		int p=0;
		scanf("%d%d%d",&n,&a,&b);
		for(i=1;i<=n;i++)
		{
			scanf("%d",&x[i]);
			x[i]-=a;/*每个均减掉下界，由于分两组所需元素不同，下界要记录*/ 
		}
		for(i=1;i<=n;i++)
		{
			p^=1;
			for(j=50-i;j<=50+i;j++)/*50+ (时间段a的个数),从小到大找*/
			{ 
				for(k=0;k<=5000;k++)/*2500+ (区间长b-a累加)，从小到大找*/
				{ 
					f[p][j][k]=f[p^1][j][k];
					if(k-x[i]>=0&&j-1>=0&&f[p^1][j-1][k-x[i]])/*f[p][j][k]记录对于j的最大值*/
					{
						f[p][j][k]=f[p][j][k]>(f[p^1][j-1][k-x[i]]+1)?f[p][j][k]:(f[p^1][j-1][k-x[i]]+1);
					}
					if(k+x[i]<=5000&&j-1>=0&&f[p^1][j+1][k+x[i]])
					{
						f[p][j][k]=f[p][j][k]>(f[p^1][j+1][k+x[i]]+1)?f[p][j][k]:(f[p^1][j+1][k+x[i]]+1); 
					}
				}
			}
		}
		int ans=f[p][50][2500];/*起点位于[50][2500]*/ 
		for(i=0;i<=100;i++)
		{
			if(a*(i-50)+2500<0)/*开始越下数组界跳过*/
			{
				continue;
			}
			if(a*(i-50)+2500>5000)/*i单增越数组上界结束*/
			{
				break;
			}
			ans=ans>f[p][i][a*(i-50)+2500]?ans:f[p][i][a*(i-50)+2500];/*ans是对于i的成功分组元素总个数的最大值*/ 
		}
		printf("%d\n",n-(ans-1));
	}
	return 0;
}
